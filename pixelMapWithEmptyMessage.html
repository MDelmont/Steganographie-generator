<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Stéganographie Pixel Map avec Masque Upload</title>
  <style>
    body {
      background: #111;
      color: white;
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 15px;
      padding: 20px;
    }

    .control-group {
      display: flex;
      flex-direction: column;
      width: 400px;
      gap: 10px;
      margin-bottom: 15px;
    }

    label {
      font-weight: bold;
    }

    input, textarea {
      background: #222;
      color: #fff;
      padding: 8px;
      border: 1px solid #555;
      border-radius: 4px;
      font-size: 14px;
    }

    button {
      padding: 10px 20px;
      background: #444;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
      margin: 10px 0;
    }

    button:hover {
      background: #666;
    }

    canvas {
      border: 1px solid #555;
      border-radius: 4px;
    }

    .color-preview {
      display: flex;
      gap: 5px;
      flex-wrap: wrap;
    }

    .color-box {
      width: 20px;
      height: 20px;
      border: 1px solid #333;
      border-radius: 3px;
    }
  </style>
</head>
<body>
  <h1>Stéganographie Pixel Map</h1>

  <div class="control-group">
    <label for="backgroundColors">Couleurs de fond (séparées par des virgules) :</label>
    <input type="text" id="backgroundColors" value="#FF5733, #33FF57, #3357FF, #F3FF33, #33FFF3" />
    <div class="color-preview" id="bgColorPreview"></div>

    <label for="textColors">Couleurs du texte (séparées par des virgules) :</label>
    <input type="text" id="textColors" value="#000000, #222222, #111111" />
    <div class="color-preview" id="textColorPreview"></div>

    <label for="pixelSize">Taille des pixels :</label>
    <input type="number" id="pixelSize" value="5" min="1" max="50" />

    <label for="hiddenText">Texte à cacher :</label>
    <textarea id="hiddenText" rows="2">Hello</textarea>

    <label for="textSize">Taille du texte (% du canvas) :</label>
    <input type="number" id="textSize" value="25" min="1" max="100" />

    <label for="textX">Position X du texte (%):</label>
    <input type="number" id="textX" value="50" min="0" max="100" />

    <label for="textY">Position Y du texte (%):</label>
    <input type="number" id="textY" value="50" min="0" max="100" />

    <label for="textAngle">Inclinaison du texte (°) :</label>
    <input type="number" id="textAngle" value="0" min="-360" max="360" />

    <label for="textNoise">Pourcentage de pixels bruités avec les couleurs du texte :</label>
    <input type="number" id="textNoise" value="10" min="0" max="100" />

    <label for="maskUpload">Téléverser un masque SVG :</label>
    <input type="file" id="maskUpload" accept=".svg" />

    <button onclick="generate()">Générer</button>
  </div>

  <canvas id="canvas" width="400" height="400"></canvas>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");

    let maskImage = null; // image SVG chargée par l’utilisateur

    function parseColors(str) {
      return str.split(',')
        .map(s => s.trim())
        .filter(s => /^#?([0-9A-F]{3}){1,2}$/i.test(s))
        .map(c => c.startsWith('#') ? c : '#' + c);
    }

    function updateColorPreviews(inputId, previewId) {
      const colors = parseColors(document.getElementById(inputId).value);
      const preview = document.getElementById(previewId);
      preview.innerHTML = '';
      colors.forEach(color => {
        const box = document.createElement('div');
        box.className = 'color-box';
        box.style.backgroundColor = color;
        preview.appendChild(box);
      });
    }

    document.getElementById('backgroundColors').addEventListener('input', () =>
      updateColorPreviews('backgroundColors', 'bgColorPreview')
    );
    document.getElementById('textColors').addEventListener('input', () =>
      updateColorPreviews('textColors', 'textColorPreview')
    );

    updateColorPreviews('backgroundColors', 'bgColorPreview');
    updateColorPreviews('textColors', 'textColorPreview');

    // Téléversement du masque SVG
    document.getElementById('maskUpload').addEventListener('change', function () {
      const file = this.files[0];
      if (file && file.type === 'image/svg+xml') {
        const reader = new FileReader();
        reader.onload = function (e) {
          const img = new Image();
          img.onload = function () {
            maskImage = img;
          };
          img.src = e.target.result;
        };
        reader.readAsDataURL(file);
      } else {
        alert("Veuillez téléverser un fichier SVG valide.");
        maskImage = null;
      }
    });

    function generate() {
      const bgColors = parseColors(document.getElementById('backgroundColors').value);
      const textColors = parseColors(document.getElementById('textColors').value);
      const text = document.getElementById('hiddenText').value.trim();
      const pixelSize = parseInt(document.getElementById('pixelSize').value);
      const textSizePercent = parseFloat(document.getElementById('textSize').value);
      const posXPercent = parseFloat(document.getElementById('textX').value);
      const posYPercent = parseFloat(document.getElementById('textY').value);
      const angleDeg = parseFloat(document.getElementById('textAngle').value);
      const textNoise = parseFloat(document.getElementById('textNoise').value) || 0;

      if (!text || bgColors.length === 0 || textColors.length === 0) {
        alert("Veuillez fournir un texte, des couleurs de fond et de texte.");
        return;
      }

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const cols = Math.floor(canvas.width / pixelSize);
      const rows = Math.floor(canvas.height / pixelSize);

      // Canvas temporaire pour le texte
      const temp = document.createElement('canvas');
      temp.width = cols;
      temp.height = rows;
      const tctx = temp.getContext('2d');

      tctx.fillStyle = 'white';
      tctx.fillRect(0, 0, cols, rows);

      tctx.save();
      const centerX = (posXPercent / 100) * cols;
      const centerY = (posYPercent / 100) * rows;
      const angleRad = angleDeg * Math.PI / 180;
      tctx.translate(centerX, centerY);
      tctx.rotate(angleRad);

      const fontSize = Math.floor((textSizePercent / 100) * rows);
      tctx.font = `bold ${fontSize}px monospace`;
      tctx.textAlign = 'center';
      tctx.textBaseline = 'middle';
      tctx.fillStyle = 'black';
      tctx.fillText(text, 0, 0);
      tctx.restore();

      const mask = tctx.getImageData(0, 0, cols, rows).data;

      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          const index = (y * cols + x) * 4;
          const isText = mask[index] < 128;

          let color;
          if (isText) {
            color = textColors[Math.floor(Math.random() * textColors.length)];
          } else {
            const noiseChance = Math.random() * 100;
            color = (noiseChance < textNoise)
              ? textColors[Math.floor(Math.random() * textColors.length)]
              : bgColors[Math.floor(Math.random() * bgColors.length)];
          }

          ctx.fillStyle = color;
          ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
        }
      }

      // Appliquer le masque SVG uploadé si présent
      if (maskImage) {
        ctx.globalCompositeOperation = 'destination-in';
        ctx.drawImage(maskImage, 0, 0, canvas.width, canvas.height);
        ctx.globalCompositeOperation = 'source-over';
      }
    }
  </script>
</body>
</html>
